# 数据库大作业 -- PurgeSteam

## PB19061294 武汉

### 写在前面：PurgeSteam、社交网络和其他

- 是什么：

  首先，为了让读到这篇报告的人不至于一头雾水，我先来解释一下这个项目是什么。PurgeSteam是一个专注于Steam平台上人与人之间关系的项目，正如它的名字一样，它希望能吹散自己的视野限制带来的迷雾，让你看到某个steam账号周围的关系网络是什么样子的，同时，你还可以了解到这个账号主人对游戏的品味和喜好，以便推送一些和你可能志同道合的朋友。这个项目目前在公网正常运行，你可以点击下方链接尝试使用。

- 为什么：

  其实之前就有过研究社交网络的想法，当时想做全民K歌的社交关系网。因为我觉得只有如下几个要素齐全，才能算得上是一个和现实生活对应比较“强”的社交关系。

  - **其一是不能是兴趣社区**。比如知乎、B站，绝大部分人在上面消遣时间，关注的都是自己感兴趣的话题下高人气答主的有关内容，于我而言，可能这些平台上关注的人占我线下认识的人比例不足1/10，这些对于我的想法来说不是好的社交平台。
  - **其二是信息必须是完全公开的**。信息不公开的例子很多，比如QQ空间，现在如果不登录或者即使登录了也经常看不全点赞列表、大部分人都关闭了自己的空间等等，这样是无法获得社交网络全貌的。
  - **其三是区分率高。**我可以通过一些很简单的办法来判断A/B是不是相互认识的人，同时能够达到很高的正确率。

  于是我想了很久，觉得全民K歌是很合适的选择。因为唱歌这种比较私密的事情，除非唱的很好会有很多粉丝，别的大部分都是相互之间认识的人，另外要判断可以通过除了关注之外的互动(除去套路性的评论等)比较容易的获取。但是后来放弃了这个想法，因为全民K歌这几年收缩了产品范围，不论是网页端还是小程序都几乎获取不到有用信息了，所以只能作罢。

  后来在群里聊天的时候，意外发现许多人的steam平台好友大都是认识的人，当然想想也在情理之中。steam和全民k歌最大的不同可能就是在于steam的匿名性更强了，但我们描述关系网，并不需要知道赛博世界和真实世界的对应关系。这也是本项目最初的灵感来源。

### 项目自顶而下设计方案

本项目分为以下几个部分：

- 爬虫模块：需要爬取steam的相关内容并生成规范化的函数接口
- 数据库模块：需要将爬虫模块得到的数据增改到数据库中，同时接受前端发来的数据请求
- Flask框架：
  - 前端：echart进行可视化处理、clients和页面的交互等
  - 后端：各种数据库接口、调用规范及数据验证等等

### 爬虫模块

- 设计思路：

  其实本身是想做一个人的五度关系的，但是实操之后发现，即使是一个人朋友的朋友，其数量已经达到了3000余人，这种情况下，考虑五度关系变得很不现实。最开始的设想是请求后直接爬取，后来发现这样用户需要等待的时间过长，限制这个系统的不是数据库的模块，而是爬虫部分。因此，需要减少重复爬虫量并且保证爬虫的准确性（因为实践发现在若干次正确信息之后有可能会伴随一次解析错误、有些steam游戏出现了下架的情况）

  爬虫模块定义在spiderfunc.py文件中

  下面是一些类的定义和方法说明：

  - Util类定义了爬虫类的一些共性、比如随机请求头、随机代理、最大重试次数等等，作为下列爬虫类的基类
    - 随机请求头降低了ip被ban的风险
    - 随机代理这里虽然我没有很多免费代理，但是说明这块可以独立出去很容易扩展为分布式的爬虫结构。
    - 最大重试次数保证了爬虫的准确性
  - PersonAll类定义了爬取传入id后确定的人的信息，具体如下：
    - id:传入的id:person_with_pouting_face:
    - steamid:(steam唯一的64位编码、区别于上面的id（上面的id是steamid或者自己设定的唯一id）)
    - getsomeinfo：获取steamid、姓名、签名栏、steam等级、昵称、地区
    - getoldname:获取历史名字和修改名字的时间
    - checkisprofiles：判断是自定义id还是原有steamid
    - getfriends：获取朋友列表
    - getimages：获取该人的公开照片
    - getregestertime：获取注册时间
    - getAllgroups：获取加入的群组列表
    - getAllgames：获取购买的游戏列表
    - getAllComments：获取评论列表
  - GroupAll类定义了爬取给定groupid后确定的群组信息，具体如下：
    - getsomeinfo:获取签名栏、成立时间、语言、地区
    - getgroupmember(deprecated)：获取群组成员
  - GameAll类定义了爬取传入id后确定的游戏信息，具体如下:
    - getsomething：获取game的id，game名称、发行日期、标签

  实践中发现，如果出现找不到传入id或者该人资料是私密的情况下容易报错，因此专门对这种情况做了适配。

### 数据库模块

- 数据库选择

  最开始我选择了mysql作为开发用数据库，但是发现虽然mysql对多对多的好友关系勉强可以存储，但是如果要寻找两人之间的关系或者寻找两人之间的最短路径等等就没办法了。因此纠结了很久之后我选择了图数据库neo4j，这是一个比较老牌的图数据库，以node和relationship组成。优点是有很多内置的图算法，缺点是插入两个相同结点不会冲突，导致唯一性要自己设计保证，这样就导致逐个插入的效率低下。

- 爬虫接口定义

  在爬虫数据和数据库之间我采用了一些接口类进行承接（这里有点ORM的思想了，但并不是我重复造轮子，是因为neo4j图数据库python的api--py2neo本身只给了Node和Relationship两个类，无法满足需要）

  爬虫接口定义在datastructure.py中

  - Person/Group/Game类：
    - 属性：
      - 和相应类相关的本身属性
    - 方法：
      - fulfilled:承接爬虫，填充属性
      - getdata：承接数据库、返回字典
  - friend/play/ingroup/comment类：
    - 属性：
      - 和相应关系相关的属性
    - 方法:
      - listxxx:面向爬虫、列举id对应的关系列表
      - generate:面向数据库、生成插入数据库所需的格式数据

- sql接口定义

  sql接口定义在sql.py中

  - SQL类：
    - 属性：
      - 

### 用户前端预计实现功能（接口）

- 获取已被收录的各种结点、关系数信息（getstatus）
- 给定id判断是否收录（checkpersonstatus）
- 随便逛逛（随机抽取一个id）（randomselect）
- 给定已收录id
  - 返回各种数值、历史数值（getnode）
  - 返回最后更新时间（getnode）
  - 计算得到好友亲密度排行（getmostfamilar）
  - 计算得到人物画像（getdraft）
  - 推荐可能认识的人（probablyknow）
  - 绘制身边人的关系网（nodelink）
- 给定两个已收录id
  - 返回两个id的最短路径、好友链（shortestbtw2、friendchain）
  - 返回两个id的共同群聊、游戏、好友
- 强制刷新某id数据（addvip）

match (n:Person)-[r*1..2]-(m:Person) where n.id="lujiatong" with n,m,m as e match (m)-[r*1..2]-(e) with m,reduce(temp='',data in r | type(data)) as label return distinct m.id,Id(m)
